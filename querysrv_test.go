// Copyright (C) 2014-2016 Jakob Borg and Contributors (see the CONTRIBUTORS file).

package main

import "testing"

func TestAdjustHost(t *testing.T) {
	testcases := []struct {
		input    string
		expected string
	}{
		{"relays.syncthing.net", "relays.syncthing.net"},
		{"relays.syncthing.net:80", "relays.syncthing.net:80"},
		{"", "123.123.123.123"},
		{":80", "123.123.123.123:80"},
		{"0.0.0.0", "123.123.123.123"},
		{"0.0.0.0:80", "123.123.123.123:80"},
		{"192.168.1.1", "192.168.1.1"},
		{"192.168.1.1:80", "192.168.1.1:80"},
		{"::", "123.123.123.123"},
		{"[::]:80", "123.123.123.123:80"},

		// Variations of v6 without a port
		{"1:2:3:4:5:6:7:8", "1:2:3:4:5:6:7:8"},
		{"1::", "1::"},
		{"1:2:3:4:5:6:7::", "1:2:3:4:5:6:7::"},
		{"1::8", "1::8"},
		{"1:2:3:4:5:6::8", "1:2:3:4:5:6::8"},
		{"1::7:8", "1::7:8"},
		{"1:2:3:4:5::7:8", "1:2:3:4:5::7:8"},
		{"1:2:3:4:5::8", "1:2:3:4:5::8"},
		{"1::6:7:8", "1::6:7:8"},
		{"1:2:3:4::6:7:8", "1:2:3:4::6:7:8"},
		{"1:2:3:4::8", "1:2:3:4::8"},
		{"1::5:6:7:8", "1::5:6:7:8"},
		{"1:2:3::5:6:7:8", "1:2:3::5:6:7:8"},
		{"1:2:3::8", "1:2:3::8"},
		{"1::4:5:6:7:8", "1::4:5:6:7:8"},
		{"1:2::4:5:6:7:8", "1:2::4:5:6:7:8"},
		{"1:2::8", "1:2::8"},
		{"1::3:4:5:6:7:8", "1::3:4:5:6:7:8"},
		{"::2:3:4:5:6:7:8", "::2:3:4:5:6:7:8"},
		{"::255.255.255.255", "::255.255.255.255"},
		{"::ffff:255.255.255.255", "::ffff:255.255.255.255"},
		{"::ffff:0:255.255.255.255", "::ffff:0:255.255.255.255"},
		{"2001:db8:3:4::192.0.2.33", "2001:db8:3:4::192.0.2.33"},
		{"64:ff9b::192.0.2.33", "64:ff9b::192.0.2.33"},

		// Variations of v6 with a port
		{"[1:2:3:4:5:6:7:8]:80", "[1:2:3:4:5:6:7:8]:80"},
		{"[1::]:80", "[1::]:80"},
		{"[1:2:3:4:5:6:7::]:80", "[1:2:3:4:5:6:7::]:80"},
		{"[1::8]:80", "[1::8]:80"},
		{"[1:2:3:4:5:6::8]:80", "[1:2:3:4:5:6::8]:80"},
		{"[1::7:8]:80", "[1::7:8]:80"},
		{"[1:2:3:4:5::7:8]:80", "[1:2:3:4:5::7:8]:80"},
		{"[1:2:3:4:5::8]:80", "[1:2:3:4:5::8]:80"},
		{"[1::6:7:8]:80", "[1::6:7:8]:80"},
		{"[1:2:3:4::6:7:8]:80", "[1:2:3:4::6:7:8]:80"},
		{"[1:2:3:4::8]:80", "[1:2:3:4::8]:80"},
		{"[1::5:6:7:8]:80", "[1::5:6:7:8]:80"},
		{"[1:2:3::5:6:7:8]:80", "[1:2:3::5:6:7:8]:80"},
		{"[1:2:3::8]:80", "[1:2:3::8]:80"},
		{"[1::4:5:6:7:8]:80", "[1::4:5:6:7:8]:80"},
		{"[1:2::4:5:6:7:8]:80", "[1:2::4:5:6:7:8]:80"},
		{"[1:2::8]:80", "[1:2::8]:80"},
		{"[1::3:4:5:6:7:8]:80", "[1::3:4:5:6:7:8]:80"},
		{"[::2:3:4:5:6:7:8]:80", "[::2:3:4:5:6:7:8]:80"},
		{"[::255.255.255.255]:80", "[::255.255.255.255]:80"},
		{"[::ffff:255.255.255.255]:80", "[::ffff:255.255.255.255]:80"},
		{"[::ffff:0:255.255.255.255]:80", "[::ffff:0:255.255.255.255]:80"},
		{"[2001:db8:3:4::192.0.2.33]:80", "[2001:db8:3:4::192.0.2.33]:80"},
		{"[64:ff9b::192.0.2.33]:80", "[64:ff9b::192.0.2.33]:80"},

		// Problematic cases, because net.ParseIP fails to parse IP's with zone
		// identifiers.

		// {"fe80::7:8%eth0", "fe80::7:8%eth0"},
		// {"fe80::7:8%eth1", "fe80::7:8%eth1"},
		// {"fe80::7:8%1", "fe80::7:8%1"},

		// {"[fe80::7:8%eth0]:80", "[fe80::7:8%eth0]:80"},
		// {"[fe80::7:8%eth1]:80", "[fe80::7:8%eth1]:80"},
		// {"[fe80::7:8%1]:80", "[fe80::7:8%1]:80"},

		// These actually succeed, and the fact that the parse fails gives us
		// expected results.
		{"::%eth0", "123.123.123.123"},
		{"[::%eth0]:80", "123.123.123.123:80"},
		{"::%Windows Puts Spaces Here", "123.123.123.123"},
		{"[::%Windows Puts Spaces Here]:80", "123.123.123.123:80"},
	}

	for i, testcase := range testcases {
		result := adjustHost(testcase.input, "123.123.123.123")
		if result != testcase.expected {
			t.Errorf("Failed at %d. Input '%s', expected '%s', got '%s'", i, testcase.input, testcase.expected, result)
		}
	}
}
